#!/usr/bin/env node

/**
 * Pylance MCP Server Launcher
 * 
 * This script launches the Python-based MCP server.
 * It handles Python environment detection and server startup.
 */

const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');
const readline = require('readline');
const http = require('http');
const https = require('https');
const { URL } = require('url');

// Find Python executable
function findPython() {
  const pythonCommands = ['python3', 'python', 'py'];
  
  for (const cmd of pythonCommands) {
    try {
      const { status } = require('child_process').spawnSync(cmd, ['--version'], {
        stdio: 'ignore'
      });
      
      if (status === 0) {
        return cmd;
      }
    } catch (e) {
      continue;
    }
  }
  
  console.error('Error: Python 3.8+ is required but not found in PATH.');
  console.error('Please install Python from https://www.python.org/downloads/');
  process.exit(1);
}

// Get server.py path
const serverPath = path.join(__dirname, '..', 'server.py');

function isProxyMode() {
  const mode = (process.env.PYLANCE_MCP_MODE || '').toLowerCase();
  if (mode === 'proxy' || mode === 'remote') return true;
  return Boolean(process.env.PYLANCE_MCP_REMOTE_URL);
}

function readTextFileSafe(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch {
    return null;
  }
}

function resolveWorkspacePath(workspaceRoot, filePath) {
  if (!filePath) return null;
  const candidate = path.isAbsolute(filePath) ? filePath : path.join(workspaceRoot, filePath);
  const normalized = path.resolve(candidate);
  const root = path.resolve(workspaceRoot);
  if (!normalized.startsWith(root)) return null;
  return normalized;
}

function listPyFiles(workspaceRoot, maxFiles) {
  const results = [];
  const skipDirNames = new Set([
    '.git',
    'node_modules',
    '__pycache__',
    '.venv',
    'venv',
    'env',
    '.env',
    'dist',
    'build'
  ]);

  function walk(dir) {
    if (results.length >= maxFiles) return;
    let entries = [];
    try {
      entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
      return;
    }
    for (const entry of entries) {
      if (results.length >= maxFiles) return;
      if (entry.isDirectory()) {
        if (skipDirNames.has(entry.name)) continue;
        walk(path.join(dir, entry.name));
      } else if (entry.isFile() && entry.name.endsWith('.py')) {
        results.push(path.relative(workspaceRoot, path.join(dir, entry.name)));
      }
    }
  }

  walk(workspaceRoot);
  results.sort();
  return results;
}

function workspaceTree(workspaceRoot, maxDepth) {
  const skipDirNames = new Set([
    '.git',
    'node_modules',
    '__pycache__',
    '.venv',
    'venv',
    'env',
    '.env',
    'dist',
    'build'
  ]);

  function build(dir, depth) {
    const node = {
      name: path.basename(dir),
      type: 'directory',
      path: path.relative(workspaceRoot, dir) || '.',
      children: []
    };
    if (depth <= 0) return node;
    let entries = [];
    try {
      entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
      return node;
    }
    for (const entry of entries) {
      if (entry.name.startsWith('.') && entry.name !== '.gitignore') continue;
      const full = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        if (skipDirNames.has(entry.name)) continue;
        node.children.push(build(full, depth - 1));
      } else if (entry.isFile()) {
        node.children.push({
          name: entry.name,
          type: 'file',
          path: path.relative(workspaceRoot, full)
        });
      }
    }
    return node;
  }

  return build(workspaceRoot, maxDepth);
}

function httpJson(urlStr, method, headers, bodyObj, timeoutMs) {
  const url = new URL(urlStr);
  const lib = url.protocol === 'https:' ? https : http;
  const payload = bodyObj ? Buffer.from(JSON.stringify(bodyObj), 'utf8') : null;

  return new Promise((resolve, reject) => {
    const req = lib.request(
      {
        protocol: url.protocol,
        hostname: url.hostname,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname + url.search,
        method,
        headers: {
          ...headers,
          ...(payload ? { 'Content-Type': 'application/json', 'Content-Length': payload.length } : {})
        }
      },
      (res) => {
        let data = '';
        res.setEncoding('utf8');
        res.on('data', (chunk) => (data += chunk));
        res.on('end', () => {
          let parsed = null;
          try {
            parsed = data ? JSON.parse(data) : null;
          } catch {
            parsed = null;
          }
          resolve({ status: res.statusCode || 0, json: parsed, text: data });
        });
      }
    );

    req.on('error', reject);
    req.setTimeout(timeoutMs, () => {
      req.destroy(new Error('Request timed out'));
    });
    if (payload) req.write(payload);
    req.end();
  });
}

async function runProxy() {
  const workspaceRoot = process.env.WORKSPACE_PATH || process.cwd();
  const remoteBase = process.env.PYLANCE_MCP_REMOTE_URL || 'http://localhost:8080';
  const apiKey = process.env.PYLANCE_API_KEY || process.env.PYLANCE_MCP_API_KEY || process.env.PYRIGHT_API_KEY || '';
  const toolsListUrl = `${remoteBase.replace(/\/$/, '')}/api/v1/mcp/tools/list`;
  const toolsCallUrl = `${remoteBase.replace(/\/$/, '')}/api/v1/mcp/tools/call`;

  const rl = readline.createInterface({ input: process.stdin, crlfDelay: Infinity });

  function sendResponse(id, result, error) {
    const msg = { jsonrpc: '2.0', id };
    if (error) msg.error = error;
    else msg.result = result;
    process.stdout.write(JSON.stringify(msg) + '\n');
  }

  function normalizeToolArgs(name, args) {
    const a = { ...(args || {}) };
    if (a.file_path && !a.content && !a.code) {
      const resolved = resolveWorkspacePath(workspaceRoot, a.file_path);
      const content = resolved ? readTextFileSafe(resolved) : null;
      if (content != null) a.content = content;
    }
    if (name === 'pylanceFileSyntaxErrors' && a.file_path && a.content == null) {
      const resolved = resolveWorkspacePath(workspaceRoot, a.file_path);
      const content = resolved ? readTextFileSafe(resolved) : null;
      if (content != null) a.content = content;
    }
    if (name === 'pylanceSyntaxErrors' && a.code == null && a.content != null) {
      a.code = a.content;
    }
    return a;
  }

  async function handleInitialize(id) {
    sendResponse(id, {
      protocolVersion: '2024-11-05',
      serverInfo: { name: 'Pylance MCP Pro Proxy', version: '1.0.0' },
      capabilities: { tools: {}, resources: {} }
    });
  }

  async function handleToolsList(id) {
    try {
      const resp = await httpJson(
        toolsListUrl,
        'GET',
        apiKey ? { 'x-api-key': apiKey } : {},
        null,
        15000
      );
      if (resp.status >= 200 && resp.status < 300 && resp.json && resp.json.tools) {
        sendResponse(id, { tools: resp.json.tools });
        return;
      }
      sendResponse(id, null, { code: -32000, message: `tools/list failed (${resp.status})`, data: resp.text });
    } catch (e) {
      sendResponse(id, null, { code: -32000, message: 'tools/list failed', data: String(e && e.message ? e.message : e) });
    }
  }

  async function handleToolsCall(id, params) {
    try {
      const name = params && params.name;
      const argumentsObj = normalizeToolArgs(name, (params && params.arguments) || {});
      const resp = await httpJson(
        toolsCallUrl,
        'POST',
        apiKey ? { 'x-api-key': apiKey } : {},
        { name, arguments: argumentsObj },
        60000
      );
      if (resp.status >= 200 && resp.status < 300 && resp.json) {
        if (resp.json && Object.prototype.hasOwnProperty.call(resp.json, 'content')) {
          sendResponse(id, resp.json.content);
          return;
        }
        sendResponse(id, resp.json);
        return;
      }
      sendResponse(id, null, { code: -32000, message: `tools/call failed (${resp.status})`, data: resp.text });
    } catch (e) {
      sendResponse(id, null, { code: -32000, message: 'tools/call failed', data: String(e && e.message ? e.message : e) });
    }
  }

  async function handleResourcesList(id) {
    sendResponse(id, {
      resources: [
        { uri: 'file://{path}', description: 'Read any file in the workspace' },
        { uri: 'workspace://files', description: 'List all Python files' },
        { uri: 'workspace://structure', description: 'Get workspace directory structure' }
      ]
    });
  }

  async function handleResourcesRead(id, params) {
    const uri = params && params.uri;
    if (!uri || typeof uri !== 'string') {
      sendResponse(id, null, { code: -32602, message: 'Invalid params' });
      return;
    }
    if (uri.startsWith('file://')) {
      const rawPath = uri.replace('file://', '');
      const resolved = resolveWorkspacePath(workspaceRoot, rawPath);
      if (!resolved) {
        sendResponse(id, null, { code: -32602, message: 'Path outside workspace' });
        return;
      }
      const content = readTextFileSafe(resolved);
      if (content == null) {
        sendResponse(id, null, { code: -32602, message: 'File not found' });
        return;
      }
      sendResponse(id, { contents: [{ uri, text: content }] });
      return;
    }
    if (uri === 'workspace://files') {
      const files = listPyFiles(workspaceRoot, 5000);
      sendResponse(id, { contents: [{ uri, text: JSON.stringify(files) }] });
      return;
    }
    if (uri === 'workspace://structure') {
      const tree = workspaceTree(workspaceRoot, 6);
      sendResponse(id, { contents: [{ uri, text: JSON.stringify(tree) }] });
      return;
    }
    sendResponse(id, null, { code: -32601, message: 'Resource not found' });
  }

  rl.on('line', async (line) => {
    if (!line) return;
    let msg = null;
    try {
      msg = JSON.parse(line);
    } catch {
      return;
    }
    const id = msg.id;
    const method = msg.method;
    const params = msg.params;

    try {
      if (method === 'initialize') return await handleInitialize(id);
      if (method === 'tools/list') return await handleToolsList(id);
      if (method === 'tools/call') return await handleToolsCall(id, params);
      if (method === 'resources/list') return await handleResourcesList(id);
      if (method === 'resources/read') return await handleResourcesRead(id, params);
      sendResponse(id, null, { code: -32601, message: 'Method not found' });
    } catch (e) {
      sendResponse(id, null, { code: -32000, message: 'Unhandled error', data: String(e && e.message ? e.message : e) });
    }
  });
}

if (isProxyMode()) {
  runProxy().catch((e) => {
    process.stderr.write(String(e && e.message ? e.message : e) + '\n');
    process.exit(1);
  });
} else {
  if (!fs.existsSync(serverPath)) {
    console.error(`Error: server.py not found at ${serverPath}`);
    process.exit(1);
  }

  const python = findPython();
  const serverProcess = spawn(python, [serverPath], {
    stdio: 'inherit',
    env: {
      ...process.env,
      OTEL_SDK_DISABLED: process.env.OTEL_SDK_DISABLED || 'true',
      WORKSPACE_PATH: process.env.WORKSPACE_PATH || process.cwd()
    }
  });

  serverProcess.on('exit', (code) => {
    process.exit(code || 0);
  });

  process.on('SIGINT', () => {
    serverProcess.kill('SIGINT');
  });

  process.on('SIGTERM', () => {
    serverProcess.kill('SIGTERM');
  });
}

"""
MCP Resources Module

Implements all @mcp.resource decorators for file system operations.
"""

import logging
from pathlib import Path
from typing import List

logger = logging.getLogger(__name__)


class PylanceResources:
    """Collection of MCP resources for file system operations."""

    def __init__(self, workspace_root: str):
        """
        Initialize resources with workspace root.

        Args:
            workspace_root: Absolute path to the workspace root directory
        """
        self.workspace_root = Path(workspace_root).resolve()

    def list_workspace_files(self) -> List[str]:
        """
        Return every .py file in the current project recursively.

        Returns:
            List of relative file paths to Python files
        """
        try:
            python_files = []
            
            # Recursively find all .py files
            for py_file in self.workspace_root.rglob("*.py"):
                # Skip common directories
                skip_dirs = {
                    "__pycache__",
                    ".pytest_cache",
                    ".mypy_cache",
                    ".tox",
                    "venv",
                    "env",
                    ".venv",
                    ".env",
                    "node_modules",
                    ".git",
                    "build",
                    "dist",
                    "*.egg-info",
                }
                
                # Check if any parent is in skip_dirs
                if any(part in skip_dirs or part.endswith(".egg-info") for part in py_file.parts):
                    continue
                
                try:
                    # Get relative path
                    relative_path = py_file.relative_to(self.workspace_root)
                    python_files.append(str(relative_path))
                except ValueError:
                    # File is outside workspace root
                    continue
            
            # Sort for consistent ordering
            python_files.sort()
            
            logger.info(f"Found {len(python_files)} Python files in workspace")
            return python_files

        except Exception as e:
            logger.error(f"list_workspace_files error: {e}")
            return []

    def read_file(self, path: str) -> str:
        """
        Read file content.

        Args:
            path: Relative or absolute path to the file

        Returns:
            File content as string
        """
        try:
            file_path = Path(path)
            
            # If relative, resolve against workspace root
            if not file_path.is_absolute():
                file_path = self.workspace_root / file_path
            
            file_path = file_path.resolve()
            
            # Validate path is within workspace
            try:
                file_path.relative_to(self.workspace_root)
            except ValueError:
                raise ValueError(f"File path {path} is outside workspace root")
            
            if not file_path.exists():
                raise FileNotFoundError(f"File not found: {path}")
            
            if not file_path.is_file():
                raise ValueError(f"Path is not a file: {path}")
            
            content = file_path.read_text(encoding="utf-8")
            logger.info(f"Read file: {path} ({len(content)} bytes)")
            return content

        except Exception as e:
            logger.error(f"read_file error for {path}: {e}")
            raise

    def get_workspace_structure(self) -> dict:
        """
        Get the complete workspace structure.

        Returns:
            Dictionary representing the directory tree
        """
        try:
            def build_tree(directory: Path) -> dict:
                """Recursively build directory tree."""
                tree = {
                    "name": directory.name,
                    "type": "directory",
                    "path": str(directory.relative_to(self.workspace_root)),
                    "children": []
                }
                
                skip_dirs = {
                    "__pycache__",
                    ".pytest_cache",
                    ".mypy_cache",
                    ".tox",
                    "venv",
                    "env",
                    ".venv",
                    ".env",
                    "node_modules",
                    ".git",
                    "build",
                    "dist",
                }
                
                try:
                    for item in sorted(directory.iterdir()):
                        if item.name.startswith(".") and item.name not in [".gitignore"]:
                            continue
                        
                        if item.name in skip_dirs or item.name.endswith(".egg-info"):
                            continue
                        
                        if item.is_dir():
                            tree["children"].append(build_tree(item))
                        else:
                            tree["children"].append({
                                "name": item.name,
                                "type": "file",
                                "path": str(item.relative_to(self.workspace_root)),
                            })
                except PermissionError:
                    pass
                
                return tree
            
            structure = build_tree(self.workspace_root)
            return structure

        except Exception as e:
            logger.error(f"get_workspace_structure error: {e}")
            return {"name": "root", "type": "directory", "children": []}

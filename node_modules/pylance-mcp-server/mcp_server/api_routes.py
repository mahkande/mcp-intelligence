"""
REST API Routes

HTTP API endpoints wrapping MCP tools for web/mobile clients.
"""

import logging
from typing import List, Dict, Any, Optional
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field

from mcp_server.auth import verify_api_key_header, auth_service
from mcp_server import ai_features

logger = logging.getLogger(__name__)

# Create API router
api_router = APIRouter(prefix="/api/v1", tags=["API"])


# ==================== REQUEST/RESPONSE MODELS ====================

class AnalyzeCodeRequest(BaseModel):
    """Request model for code analysis."""
    file_path: str = Field(..., description="Path to Python file (relative to workspace)")
    content: str = Field(..., description="Python code content to analyze")
    include_type_check: bool = Field(True, description="Run full type checking")


class AnalyzeCodeResponse(BaseModel):
    """Response model for code analysis."""
    diagnostics: List[Dict[str, Any]]
    summary: Dict[str, Any]
    file_path: str


class CompletionRequest(BaseModel):
    """Request model for code completions."""
    file_path: str
    content: str
    line: int = Field(..., description="Line number (0-indexed)")
    character: int = Field(..., description="Character position (0-indexed)")


class CompletionResponse(BaseModel):
    """Response model for completions."""
    completions: List[Dict[str, Any]]
    count: int


class HoverRequest(BaseModel):
    """Request model for hover information."""
    file_path: str
    content: str
    line: int
    character: int


class HoverResponse(BaseModel):
    """Response model for hover info."""
    documentation: str
    type_info: Optional[str] = None


class DiagnosticsRequest(BaseModel):
    """Request model for diagnostics."""
    file_path: str
    content: str


class DiagnosticsResponse(BaseModel):
    """Response model for diagnostics."""
    errors: List[Dict[str, Any]]
    warnings: List[Dict[str, Any]]
    information: List[Dict[str, Any]]
    summary: Dict[str, int]


class McpToolCallRequest(BaseModel):
    name: str
    arguments: Dict[str, Any] = Field(default_factory=dict)


# ==================== API ENDPOINTS ====================

@api_router.post("/analyze", response_model=AnalyzeCodeResponse)
async def analyze_code(
    request: AnalyzeCodeRequest,
    user: dict = Depends(verify_api_key_header)
):
    """
    Analyze Python code for errors, warnings, and type issues.
    
    Returns comprehensive diagnostics with severity levels.
    """
    try:
        from server import tools
        
        if not tools:
            raise HTTPException(status_code=503, detail="Server not initialized")
        
        # Get diagnostics
        diagnostics = tools.get_diagnostics(request.file_path, request.content)
        
        # If type checking requested, add full type check
        if request.include_type_check:
            type_check_result = tools.type_check(
                file_path=request.file_path,
                content=request.content
            )
            diagnostics.extend(type_check_result.get("diagnostics", []))
        
        # Summarize by severity
        summary = {
            "total_errors": sum(1 for d in diagnostics if d.get("severity") == "error"),
            "total_warnings": sum(1 for d in diagnostics if d.get("severity") == "warning"),
            "total_info": sum(1 for d in diagnostics if d.get("severity") in ["information", "hint"])
        }
        
        # Log usage
        await auth_service.log_usage(user["api_key"], "analyze", tokens=len(request.content))
        
        return AnalyzeCodeResponse(
            diagnostics=diagnostics,
            summary=summary,
            file_path=request.file_path
        )
        
    except Exception as e:
        logger.error(f"Analyze error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/complete", response_model=CompletionResponse)
async def get_completions(
    request: CompletionRequest,
    user: dict = Depends(verify_api_key_header)
):
    """
    Get code completions at a specific position.
    
    Returns intelligent suggestions with type information.
    """
    try:
        from server import tools
        
        if not tools:
            raise HTTPException(status_code=503, detail="Server not initialized")
        
        completions = tools.get_completions(
            file_path=request.file_path,
            line=request.line,
            character=request.character,
            content=request.content
        )
        
        # Log usage
        await auth_service.log_usage(user["api_key"], "complete", tokens=len(request.content))
        
        return CompletionResponse(
            completions=completions,
            count=len(completions)
        )
        
    except Exception as e:
        logger.error(f"Completion error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/hover", response_model=HoverResponse)
async def get_hover_info(
    request: HoverRequest,
    user: dict = Depends(verify_api_key_header)
):
    """
    Get type information and documentation for a symbol.
    
    Returns hover information like in VS Code.
    """
    try:
        from server import tools
        
        if not tools:
            raise HTTPException(status_code=503, detail="Server not initialized")
        
        hover_text = tools.get_hover(
            file_path=request.file_path,
            line=request.line,
            character=request.character,
            content=request.content
        )
        
        # Log usage
        await auth_service.log_usage(user["api_key"], "hover")
        
        return HoverResponse(
            documentation=hover_text,
            type_info=hover_text  # Can be parsed further
        )
        
    except Exception as e:
        logger.error(f"Hover error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/diagnostics", response_model=DiagnosticsResponse)
async def get_diagnostics(
    request: DiagnosticsRequest,
    user: dict = Depends(verify_api_key_header)
):
    """
    Get all diagnostics (errors, warnings, info) for a file.
    
    Returns categorized diagnostics with line numbers.
    """
    try:
        from server import tools
        
        if not tools:
            raise HTTPException(status_code=503, detail="Server not initialized")
        
        all_diagnostics = tools.get_diagnostics(request.file_path, request.content)
        
        # Categorize by severity
        errors = [d for d in all_diagnostics if d.get("severity") == "error"]
        warnings = [d for d in all_diagnostics if d.get("severity") == "warning"]
        information = [d for d in all_diagnostics if d.get("severity") in ["information", "hint"]]
        
        summary = {
            "errors": len(errors),
            "warnings": len(warnings),
            "information": len(information)
        }
        
        # Log usage
        await auth_service.log_usage(user["api_key"], "diagnostics", tokens=len(request.content))
        
        return DiagnosticsResponse(
            errors=errors,
            warnings=warnings,
            information=information,
            summary=summary
        )
        
    except Exception as e:
        logger.error(f"Diagnostics error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/usage")
async def get_usage_stats(user: dict = Depends(verify_api_key_header)):
    """
    Get API usage statistics for the current user.
    
    Returns request counts, rate limit status, and billing info.
    """
    try:
        # TODO: Query Supabase usage_logs table
        # For now, return mock data
        return {
            "user_id": user["user_id"],
            "tier": user["tier"],
            "current_period": {
                "requests_made": 150,
                "requests_limit": 5000 if user["tier"] == "pro" else 20,
                "tokens_used": 45000,
                "reset_at": "2025-12-19T00:00:00Z"
            },
            "rate_limit": {
                "hourly_limit": 5000 if user["tier"] == "pro" else 20,
                "daily_limit": 50000 if user["tier"] == "pro" else 100
            }
        }
    except Exception as e:
        logger.error(f"Usage stats error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/mcp/tools/list")
async def mcp_tools_list(user: dict = Depends(verify_api_key_header)):
    try:
        import server

        allowed = getattr(server, "EXPORTED_MCP_TOOL_NAMES", None)
        if not allowed:
            raise HTTPException(status_code=503, detail="MCP tool catalog not available")

        tools_list = []
        for name in allowed:
            func = getattr(server, name, None)
            description = ""
            if callable(func):
                description = (getattr(func, "__doc__", "") or "").strip().split("\n")[0]

            tools_list.append({
                "name": name,
                "description": description,
                "inputSchema": {
                    "type": "object",
                    "additionalProperties": True
                }
            })

        return {"tools": tools_list}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"MCP tools/list error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/mcp/tools/call")
async def mcp_tools_call(
    request: McpToolCallRequest,
    user: dict = Depends(verify_api_key_header),
):
    try:
        import server

        allowed = getattr(server, "EXPORTED_MCP_TOOL_NAMES", None) or []
        if request.name not in allowed:
            raise HTTPException(status_code=404, detail="Tool not found")

        func = getattr(server, request.name, None)
        if not callable(func):
            raise HTTPException(status_code=404, detail="Tool not found")

        result = func(**(request.arguments or {}))
        await auth_service.log_usage(user["api_key"], f"mcp:{request.name}")
        return {"content": result}
    except TypeError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"MCP tools/call error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== AI FEATURES (PRO TIER ONLY) ====================

class ExplainErrorRequest(BaseModel):
    """Request model for AI type error explanations."""
    code: str
    error_message: str
    file_path: str
    line_number: int


class ExplainErrorResponse(BaseModel):
    """Response model for error explanations."""
    explanation: str
    model: str
    tokens_used: int


class EnhanceTypesRequest(BaseModel):
    """Request model for AI type enhancement."""
    code: str
    file_path: str
    existing_types: Optional[List[Dict[str, Any]]] = []


class EnhanceTypesResponse(BaseModel):
    """Response model for type enhancements."""
    suggestions: str
    model: str
    tokens_used: int


@api_router.post("/explain-error", response_model=ExplainErrorResponse)
async def explain_type_error(
    request: ExplainErrorRequest,
    user: dict = Depends(verify_api_key_header)
):
    """
    AI-powered type error explanation (PRO tier only).
    
    Uses Claude to explain type errors in beginner-friendly language with fix suggestions.
    """
    try:
        tier = (user.get("tier") or "").lower()
        if tier not in ("pro", "professional", "enterprise"):
            raise HTTPException(
                status_code=403,
                detail="AI features require PRO tier. Upgrade at pylancemcp.com/pricing"
            )
        
        result = await ai_features.explain_type_error(
            code=request.code,
            error_message=request.error_message,
            file_path=request.file_path,
            line_number=request.line_number
        )
        
        if not result["success"]:
            raise HTTPException(status_code=500, detail=result.get("error", "AI processing failed"))
        
        # Log usage
        await auth_service.log_usage(
            user["api_key"],
            "explain-error",
            tokens=result["tokens_used"]
        )
        
        return ExplainErrorResponse(
            explanation=result["explanation"],
            model=result["model"],
            tokens_used=result["tokens_used"]
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Explain error failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/enhance-types", response_model=EnhanceTypesResponse)
async def enhance_type_annotations(
    request: EnhanceTypesRequest,
    user: dict = Depends(verify_api_key_header)
):
    """
    AI-powered type annotation suggestions (PRO tier only).
    
    Uses Claude to suggest improved type annotations for Python code.
    """
    try:
        tier = (user.get("tier") or "").lower()
        if tier not in ("pro", "professional", "enterprise"):
            raise HTTPException(
                status_code=403,
                detail="AI features require PRO tier. Upgrade at pylancemcp.com/pricing"
            )
        
        result = await ai_features.enhance_type_annotations(
            code=request.code,
            file_path=request.file_path,
            existing_types=request.existing_types or []
        )
        
        if not result["success"]:
            raise HTTPException(status_code=500, detail=result.get("error", "AI processing failed"))
        
        # Log usage
        await auth_service.log_usage(
            user["api_key"],
            "enhance-types",
            tokens=result["tokens_used"]
        )
        
        return EnhanceTypesResponse(
            suggestions=result["suggestions"],
            model=result["model"],
            tokens_used=result["tokens_used"]
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Enhance types failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/analyze-patterns")
async def analyze_code_patterns_endpoint(
    code: str,
    diagnostics: List[Dict[str, Any]],
    user: dict = Depends(verify_api_key_header)
):
    """
    AI-powered code pattern analysis (PRO tier only).
    
    Identifies anti-patterns and suggests improvements.
    """
    try:
        tier = (user.get("tier") or "").lower()
        if tier not in ("pro", "professional", "enterprise"):
            raise HTTPException(status_code=403, detail="AI features require PRO tier")
        
        result = await ai_features.analyze_code_patterns(code, diagnostics)
        
        if not result["success"]:
            raise HTTPException(status_code=500, detail=result.get("error"))
        
        await auth_service.log_usage(user["api_key"], "analyze-patterns", tokens=result["tokens_used"])
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Pattern analysis failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))
        raise HTTPException(status_code=500, detail=str(e))

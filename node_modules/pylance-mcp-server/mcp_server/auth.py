"""
Authentication Middleware

Handles API key verification, subscription tier checks, and rate limiting.
Uses Firebase Admin SDK for authentication.
"""

import logging
import os
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import Header, HTTPException
from collections import defaultdict
import hashlib
import requests

logger = logging.getLogger(__name__)

# In-memory rate limiting (use Redis in production)
rate_limit_store: Dict[str, list] = defaultdict(list)

# Firebase Admin SDK initialization
_firebase_initialized = False

def _init_firebase():
    """Initialize Firebase Admin SDK."""
    global _firebase_initialized
    if _firebase_initialized:
        return
    
    try:
        import firebase_admin
        from firebase_admin import credentials
        import base64
        
        # Try FIREBASE_SERVICE_ACCOUNT first (single JSON blob)
        service_account_json = os.getenv("FIREBASE_SERVICE_ACCOUNT")
        if service_account_json:
            cred_dict = json.loads(service_account_json)
            cred = credentials.Certificate(cred_dict)
            firebase_admin.initialize_app(cred)
        elif os.getenv("FIREBASE_PRIVATE_KEY_BASE64") and os.getenv("FIREBASE_CLIENT_EMAIL") and os.getenv("FIREBASE_PROJECT_ID"):
            # Use base64-encoded private key (Vercel-safe)
            private_key_b64 = os.getenv("FIREBASE_PRIVATE_KEY_BASE64")
            private_key = base64.b64decode(private_key_b64).decode("utf-8")
            
            cred_dict = {
                "type": "service_account",
                "project_id": os.getenv("FIREBASE_PROJECT_ID"),
                "client_email": os.getenv("FIREBASE_CLIENT_EMAIL"),
                "private_key": private_key,
                "token_uri": "https://oauth2.googleapis.com/token",
            }
            cred = credentials.Certificate(cred_dict)
            firebase_admin.initialize_app(cred)
        elif os.getenv("FIREBASE_PROJECT_ID"):
            # Fallback: just project ID (limited functionality)
            firebase_admin.initialize_app(options={
                "projectId": os.getenv("FIREBASE_PROJECT_ID")
            })
        else:
            logger.warning("Firebase not configured - set FIREBASE_SERVICE_ACCOUNT or FIREBASE_PROJECT_ID + FIREBASE_CLIENT_EMAIL + FIREBASE_PRIVATE_KEY_BASE64")
            return
        
        _firebase_initialized = True
        logger.info("Firebase Admin SDK initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize Firebase: {e}")


class AuthService:
    """Authentication and authorization service using Firebase."""
    
    def __init__(self) -> None:
        """Initialize auth service."""
        _init_firebase()
        
        # Firebase configuration
        self.firebase_project_id = os.getenv("FIREBASE_PROJECT_ID")
        
        # API wrapper URL for validating API keys
        self.api_wrapper_url = os.getenv("API_WRAPPER_URL") or os.getenv("PUBLIC_FLY_API_URL") or "https://api-wrapper-empty-wildflower-5195.fly.dev"
        self.internal_api_secret = os.getenv("INTERNAL_API_SECRET")

        # Simple in-memory cache: api_key_hash -> (expires_at_utc, user_info)
        self._cache: Dict[str, Any] = {}
        self._cache_ttl_seconds = int(os.getenv("AUTH_CACHE_TTL_SECONDS", "60"))
        
        # Rate limits per tier (aligned with api-wrapper/database.js)
        self.rate_limits = {
            "free": {"requests_per_minute": 10, "requests_per_month": 150},
            "starter": {"requests_per_minute": 10, "requests_per_month": 150},
            "hobby": {"requests_per_minute": 10, "requests_per_month": 150},
            "pro": {"requests_per_minute": 100, "requests_per_month": 10000},
            "professional": {"requests_per_minute": 100, "requests_per_month": 10000},
            "enterprise": {"requests_per_minute": 1000, "requests_per_month": 1000000},  # 1M/month cap for security
        }

    def _sha256_hex(self, value: str) -> str:
        return hashlib.sha256(value.encode("utf-8")).hexdigest()

    async def _validate_api_key_via_wrapper(self, api_key: str) -> Optional[Dict[str, Any]]:
        """Validate API key by calling the API wrapper service."""
        try:
            headers = {"x-api-key": api_key}
            if self.internal_api_secret:
                headers["x-internal-secret"] = self.internal_api_secret
            
            resp = requests.get(
                f"{self.api_wrapper_url}/v1/validate-key",
                headers=headers,
                timeout=10
            )
            
            if resp.status_code == 200:
                return resp.json()
            return None
        except Exception as e:
            logger.error(f"Failed to validate API key via wrapper: {e}")
            return None

    async def verify_api_key(self, api_key: str) -> Dict[str, Any]:
        """
        Verify API key and return user info with subscription tier.
        
        Args:
            api_key: API key from request header
            
        Returns:
            Dictionary with user_id, email, tier, and permissions
            
        Raises:
            HTTPException: If API key is invalid or expired
        """
        if not api_key:
            raise HTTPException(status_code=401, detail="API key required")
        
        # Allow test keys
        if api_key.startswith("test_"):
            return {
                "user_id": "test_user",
                "email": "test@example.com",
                "tier": "pro",
                "api_key": api_key,
                "active": True
            }

        api_key_hash = self._sha256_hex(api_key)
        now = datetime.utcnow()

        # Check cache first
        cached = self._cache.get(api_key_hash)
        if cached:
            expires_at, user_info = cached
            if expires_at > now:
                return user_info
            self._cache.pop(api_key_hash, None)

        # Validate via API wrapper
        result = await self._validate_api_key_via_wrapper(api_key)
        if not result:
            raise HTTPException(status_code=401, detail="Invalid API key")
        
        user_info = {
            "user_id": result.get("customer_id") or result.get("user_id"),
            "email": result.get("email", ""),
            "tier": result.get("plan_name") or result.get("tier") or "free",
            "api_key": api_key,
            "active": True,
        }

        # Cache the result
        self._cache[api_key_hash] = (now + timedelta(seconds=self._cache_ttl_seconds), user_info)
        return user_info
    
    async def check_rate_limit(self, api_key: str, tier: str) -> bool:
        """
        Check if request is within rate limits for the tier.
        
        Args:
            api_key: User's API key
            tier: Subscription tier (free/starter/hobby/pro/enterprise)
            
        Returns:
            True if within limits, raises HTTPException otherwise
        """
        now = datetime.utcnow()
        minute_ago = now - timedelta(minutes=1)
        
        # Clean old entries (keep last minute for per-minute limiting)
        rate_limit_store[api_key] = [
            ts for ts in rate_limit_store[api_key] if ts > minute_ago
        ]
        
        # Check per-minute limit
        current_count = len(rate_limit_store[api_key])
        tier_lower = tier.lower() if tier else "free"
        limits = self.rate_limits.get(tier_lower, self.rate_limits["free"])
        limit = limits["requests_per_minute"]
        
        if current_count >= limit:
            raise HTTPException(
                status_code=429,
                detail=f"Rate limit exceeded. Limit: {limit} requests/minute. "
                       f"Upgrade to Pro for higher limits."
            )
        
        # Add current request
        rate_limit_store[api_key].append(now)
        return True
    
    async def log_usage(self, api_key: str, endpoint: str, tokens: int = 0) -> None:
        """
        Log API usage for analytics and billing.
        
        Args:
            api_key: User's API key
            endpoint: API endpoint called
            tokens: Number of tokens processed (if applicable)
        """
        # TODO: Insert into Supabase usage_logs table
        logger.info(f"Usage: {api_key[:8]}... -> {endpoint} ({tokens} tokens)")


# Global auth service instance
auth_service = AuthService()


async def verify_api_key_header(
    x_api_key: str = Header(..., description="Your API key")
) -> Dict[str, Any]:
    """
    FastAPI dependency for API key verification.
    
    Usage:
        @app.post("/api/v1/analyze")
        async def analyze(user: dict = Depends(verify_api_key_header)):
            # user has: user_id, email, tier, api_key, active
            pass
    """
    user = await auth_service.verify_api_key(x_api_key)
    await auth_service.check_rate_limit(x_api_key, user["tier"])
    return user
